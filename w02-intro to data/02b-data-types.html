<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Data Types</title>
    <meta charset="utf-8" />
    <meta name="author" content="Dr. Mine Dogucu, UCI" />
    <script src="02b-data-types_files/header-attrs-2.29/header-attrs.js"></script>
    <link rel="stylesheet" href="slide-style.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">


class: title-slide





&lt;br&gt;
&lt;br&gt;
.right-panel[ 

# Data Types
## Dr. Mine Dogucu, UCI
## Alma Castro, Cypress College
]

---



## Variables

__Variables__: Characteristics of the individuals within the population.                                            

Variables can be classified into two groups: categorical or numeric.


&lt;img src="img/diagram_small.png" width="50%" style="display: block; margin: auto;" /&gt;

---

## Categorical Variables

__Categorical__ (qualitative) variables allows for individuals to be classified based on some attribute or characteristic.

* Variables such as `eye_color` (brown, blue, black, green, other), `own_car` (true, false), `class_year` (freshman, sophomore, junior, senior) are _categorical variables_. 

--

Categorical variables have __levels__ (categories). For instance `own_car` has two levels, and `class_year` has four levels.

---

## Numerical Variables

__Numeric__ (quantitative) variables provides numerical measures of individuals.

* Variables  such as `n_kids` (number of kids), `height`, and `course_units` are _numerical variables_. 

--

We can do certain analyses using these variables such as finding an average or the maximum or minimum.

--

Not everything represented by numbers represents a numeric quantity. e.g. student ID, cell phone number, zip code. 

---

### candy_rankings

&lt;img src="img/data-candy.png" width="100%" style="display: block; margin: auto;" /&gt;

--

Categorical variables: 

- `chocolate`, `fruity`

--

Numeric variables: 

- `sugarpercent`, `pricepercent`, `winpercent`

---

### Categorical Variables

Categorical variables can be further classified as either nominal or ordinal. 

* _Nominal_ variables have categories that do not follow a natural order. Hence, these can be ordered by alphabetical order or based on highest frequency, or any way that makes sense of the data being presented. 
    
    e.g. `eye_color`, `race`, `gender`

--

* _Ordinal_ variables have categories that have a natural order. 
    
    e.g. `course_grade`, `class_year`, `t-shirt_size`

&lt;img src="img/diagram-cat.png" style="display: block; margin: auto;" /&gt;

---

### Numerical Variables

Numerical variables can be further classified as either continuous or discrete.                                           

* _Continuous_ variables are not countable and have an infinite number of possible values. Any decimal value make sense. Continuous variables can be measured to a certain precision, e.g. days, hours, minutes, seconds, ... 
    
    e.g. `weight`, `commute_time`

--

* _Discrete_ variables have a finite or countable number of possible values. 
    
    e.g. `n_kids`, `class_units`

&lt;img src="img/diagram-num.png" style="display: block; margin: auto;" /&gt;


---


``` r
glimpse(candy_rankings)
```

```
## Rows: 85
## Columns: 13
## $ competitorname   &lt;chr&gt; "100 Grand", "3 Musketeers", "One dime", "One quarter…
## $ chocolate        &lt;lgl&gt; TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, F…
## $ fruity           &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE…
## $ caramel          &lt;lgl&gt; TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE,…
## $ peanutyalmondy   &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, …
## $ nougat           &lt;lgl&gt; FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE,…
## $ crispedricewafer &lt;lgl&gt; TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE…
## $ hard             &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALS…
## $ bar              &lt;lgl&gt; TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, F…
## $ pluribus         &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE…
## $ sugarpercent     &lt;dbl&gt; 0.732, 0.604, 0.011, 0.011, 0.906, 0.465, 0.604, 0.31…
## $ pricepercent     &lt;dbl&gt; 0.860, 0.511, 0.116, 0.511, 0.511, 0.767, 0.767, 0.51…
## $ winpercent       &lt;dbl&gt; 66.97173, 67.60294, 32.26109, 46.11650, 52.34146, 50.…
```

---


``` r
glimpse(mariokart)
```

```
## Rows: 143
## Columns: 12
## $ id          &lt;dbl&gt; 150377422259, 260483376854, 320432342985, 280405224677, 17…
## $ duration    &lt;int&gt; 3, 7, 3, 3, 1, 3, 1, 1, 3, 7, 1, 1, 1, 1, 7, 7, 3, 3, 1, 7…
## $ n_bids      &lt;int&gt; 20, 13, 16, 18, 20, 19, 13, 15, 29, 8, 15, 15, 13, 16, 6, …
## $ cond        &lt;fct&gt; new, used, new, new, new, new, used, new, used, used, new,…
## $ start_pr    &lt;dbl&gt; 0.99, 0.99, 0.99, 0.99, 0.01, 0.99, 0.01, 1.00, 0.99, 19.9…
## $ ship_pr     &lt;dbl&gt; 4.00, 3.99, 3.50, 0.00, 0.00, 4.00, 0.00, 2.99, 4.00, 4.00…
## $ total_pr    &lt;dbl&gt; 51.55, 37.04, 45.50, 44.00, 71.00, 45.00, 37.02, 53.99, 47…
## $ ship_sp     &lt;fct&gt; standard, firstClass, firstClass, standard, media, standar…
## $ seller_rate &lt;int&gt; 1580, 365, 998, 7, 820, 270144, 7284, 4858, 27, 201, 4858,…
## $ stock_photo &lt;fct&gt; yes, yes, no, yes, yes, yes, yes, yes, yes, no, yes, yes, …
## $ wheels      &lt;int&gt; 1, 1, 1, 1, 2, 0, 0, 2, 1, 1, 2, 2, 2, 2, 1, 0, 1, 1, 2, 2…
## $ title       &lt;fct&gt; "~~ Wii MARIO KART &amp;amp; WHEEL ~ NINTENDO Wii ~ BRAND NEW …
```

---
class: middle

`character` (`chr`): takes string values (e.g. a person's name, address)  
--

`integer` (`int`): integer (single precision)  
--

`double` (`dbl`): floating decimal (double precision)   
--

`numeric` (`num`): integer or double  
--

`factor` (`fct`): categorical variables with different levels  
--

`logical` (`lgl`): TRUE (1), FALSE (0)  

---

class: inverse middle

As a data scientist it is .font30[**your**] job to check the type(s) of data that you are working with. 
  The type of variables you have will determine the type of analysis you will do. 

Do .font30[**not**]  assume you will work with clean data frames, with clean names, labels, and types. 


---

class: inverse middle

## Data Wrangling

  One of the first steps you'll do as a data scientist, is to determine if you have "clean" data, if you don't then it is a good idea to __tidy__ and __transform__ it to get the data in a form that is natural to work with. 
  
- __Tidying__ data means to put your data in a way that every column is a variable and every row is an observation.
    
- __Transformation__ includes narrowing in on observations of interest,  creating new variables that are functions of existing variables (like computing speed from distance and time), changing data types, and cleaning names. 
    
Together, tidying and transforming data is called __data wrangling__. 

---
## Data Types Activity

Download the "02b-data-types-activity.rmd" file from the Canvas activity, and answer the following questions using the `titanic_train` data frame.

1. How many observations are there in this data set?

2. How many variables are there in this data set?

3. Which variables are considered categorical? 

4. Which variables are considered numeric?

5. Determine if the type of data for each variable was read correctly by R, if not then specify the most appropriate type of variable that it should be. Use the help feature to find more information about the variables if needed. 
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "pygments",
"highlightLines": true,
"highlightLanguage": "r"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
